# 递归和动态规划

- 共同特点：

  - 需要求解的问题可以进一步分割为规模更小的子问题（由 subproblem 到 problem）。
  - 求解第 $n$ 个问题可能需要用到第 $1,\dots,n-1$ 个问题的结果。

- 动态规划的两种形式

  - Bottom-Up（自底向上、迭代）：
    - 离散、有限、整数空间
    - 可能会求解不必要的子问题，但是不会重复求解子问题
    - 需要手动初始化边界
    - 适合处理不需要罗列，只需要判断是否存在或者求极值或者求总和的问题（强收敛性问题） 
  - Memorization（自顶向下、递归）：
    - 按需记录、灵活，但是可能会重复求解子问题（可以通过哈希表记录来解决）
    - 符合常规思维逻辑，易于理解
    - 需要考虑递归本身的空间复杂度（ $O(n)$ ，$n$ 为递归深度）
    - 使用递归基作为边界条件，不容易遗漏
    - 适合处理需要罗列的问题（不需要回溯）

- 收敛问题和发散问题

  - 收敛：多项式复杂度
  - 发散：指数或者阶乘复杂度

- 贪心算法和动态规划的区别

  - 贪心算法
    - 每次都选择当前的最优解，并且选择该最优解不会影响之后的问题求解
  - 动态规划
    - 记录下当前所有的可行解，以备求解之后的问题时使用

- 动态规划的相关技巧

  - 优化空间复杂度的方法：如果一个维度上第 $n$ 个值仅与第 $n-1$ 个值有关，则该维度可从 $O(n)$ 规模的空间优化为 $O(1)$ 规模的空间
  - 循环变量递增递减的选择：如果 `dp[i][j] = f(dp[i-1][j+1])` ，那么循环变量 `i` 应该递增，`j`应该递减
  - 子序列最优问题的建模：用 `dp[n]` 表示以 `n` 为末节点的序列的相应子问题，而不是用实际最优子序列的首末位置作为递推变量（至少要固定一个边，不需要两边同时搜索）
  - 两边夹问题的处理：如果`dp[i] = f(dp[i-1], dp[i+1])`，那么这就是一个两边夹问题，可以自左向右进行一次DP，再自右向左进行一次DP，从而解决该类问题

-  一个 `backtracking` 模板：

  ```c++
  void backtracking(P point, vector<P>& path, vector<vector<P>>& paths) {
    if (!point) {
      return;
    }
    path.push_back(point);
    bool success = __;
    if (success) {
      paths.push_back(path);
    }
    for (next : all_directions) {
      backtracking(next, path, paths);
      __; // 剪枝
    }
    path.pop_back(); // 消除痕迹
    return;
  }
  ```

- 分而治之：时间复杂度往往跟 $O(\text {logN})$ 有关