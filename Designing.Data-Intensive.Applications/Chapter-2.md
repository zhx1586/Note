# 第二章 数据模型和查询语言

数据模型可能是开发软件时最重要的部分，因为数据模型不仅会影响软件如何编写，还会影响我们如何考虑要解决的问题。

大部分应用都是通过将数据模型逐层堆叠来构建的。对于每一个数据模型层，关键问题是：如何用紧邻的较低层的模型表达当前层？比如：

- 应用软件开发者会将真实世界建模为对象和数据结构，API则是用来操作这些数据结构的。这些结构经常是为具体应用定制的。

- 在存储数据结构时，需要首先将其表达为通用的数据模型，比如JSON或者XML文档、关系型数据库中的表或者图模型。

- 数据库软件开发者会选择将JSON/XML/关系型/图数据存储到内存、硬盘或者网络上，从而使这些数据可以被查询、搜索、操作或者按照各种方式处理。

- 在更加底层的层中，硬件工程师会选择将字节数据存储在各种硬件中。

在复杂应用中，存在着更多的中间层，但是基本的思想也是相同的：每一层向更高层隐藏属于当前层的复杂性，通过提供更加简洁的数据模型。这种抽象使得不同团队的人在一起高效地合作。

存在不同种类的数据模型，每种数据模型都是基于其存储数据的使用方式来构建的。部分使用方式是简单的，而其他使用方式是不支持的；部分操作是处理速度快的，而另外一部分操作是处理速度慢的；有些数据转换方式是自然的，而另外一些数据转换方式是笨拙的。

由于数据模型对于使用者能做和不能做的事情，有着如此深刻的影响，选择合适的数据模型是十分重要的。

在本章中，我们将介绍一系列通用的、用于数据存储或者查询的数据模型。特别是，对关系模型、文档模型和一部分基于图的模型的比较。我们也会介绍多种查询语言，以及它们适用的场景。在第三章中，我们将讨论存储引擎是如何工作的，即这些数据模型是如何实现的。

## 关系模型vs文档模型

最广为人知的数据模型是，基于关系模型的SQL。数据被组织为**关系**（SQL中的表），每个关系是**元组**（SQL中的行）的无序集合。

关系模型是一种理论上的设想，当时有许多人质疑其能否高效地实现。然而，在80年代中期，关系型数据库管理系统（RDBMS）和SQL已经成为了存储数据和查询数据的最佳选择。

那时的其他数据库会要求应用开发人员去大量思考数据库中数据的内部表达方式。关系模型的目标是将这些实现细节隐藏在简洁的接口层之下。

### NoSQL的诞生

**NoSQL**被解释为**Not Only SQL**。NoSQL数据库出现的背后有着多种推动力：

- 对于关系型数据库很难实现的高度伸缩性的需要，包括更大的数据量或者更快的写入吞吐量。

- 对于免费、开源软件而不是商业数据库产品的偏好。

- 对于关系型数据库通常不支持的特殊查询操作的需要。

- 对于关系型模式限制的失望，以及对更加灵活、更具表达性的数据模型的需要。

不同的应用有着不同的要求，不同应用的最佳技术方案选择也是不同的。因此，在可以预见的将来，关系型数据库会继续与一系列不同的非关系型数据库共同使用，这种方式有时也被称为**混合持久化**。

### 对象关系不匹配

如今大部分应用程序都是使用面向对象编程语言开发的，这会与关系数据模型之间产生矛盾：如果数据存储在关系型数据库中，就必须要增加一个额外的转换层，才能将应用程序代码中的对象转化为数据模型中的表、行和列。这种情况有时也被称为**阻抗不匹配**（impedance mismatch）。

对象关系映射（ORM）框架可以减少转换层所需的模版代码数量，但是仍然无法完全隐藏两种模型之间的差异。

有些开发者认为JSON模型可以降低应用层与存储层之间的阻抗不匹配。然而，我们将在第四章中看到，使用JSON作为数据编码方式也会存在其他问题。

JSON模型与关系型模型相比，具有更好的**定位性**（locality）。如果你需要从关系模型中查询一些属性，那么你需要多次查询或者进行复杂的表联结（join）操作。使用JSON模型时，所有关联的信息都组织在一起，一次查询就足够了。

在一对多关系中，JSON模型可以更加直观地呈现数据之间的树形结构。

### 多对一和多对多关系

如果用户接口允许按照纯文本字段的方式来输入地区、行业等信息，那么将这些数据按照纯文本的字符串来存储也是说得通的。但是用标准化的地区、行业列表也是有好处的，这种方式可以让用户从一个下拉列表中选择或者为用户自动补全这些信息：

- 在不同配置文件中，保持一贯的风格和拼写。

- 避免歧义（比如，如果多个城市重名时）。

- 更新时更简单，如果名称仅存储了一处，在需要更新时（比如，由于政治事件改变城市名）更加方便。

- 支持本地化，当网站被翻译为其他语言时，标准化列表可以被本地化，因此地区、行业信息也可以被显示为需要的语言。

- 方便搜索，可以按照经标准化列表编码后的指搜索，而不是直接搜索文本，减少无关的匹配。

不论是存储ID还是文本字符串，都会存在重复的问题。存储ID时，对人有意义的信息只保存了一处，在每次使用到时使用的都是ID，这个ID只在数据库中有意义。存储文本字符串时，会在每个使用到的地方都重复记录了仅对人有意义的信息。

使用ID的好处在于不会被修改，由于ID对人是没有意义的，如果其代表的信息发生了变化，ID本身可以保持不变。任何对人有意义的信息都有可能在未来被修改，如果这个信息是重复的，所有冗余的拷贝都需要随之更新。这可能会带来写覆盖或者不一致的风险（当只有其中一部分拷贝被成功修改时）。消除这种重复正是数据库**范式**（normalization）的核心思想。

不幸的是，对数据进行范式化需要**多对一**关系（很多人生活在一个特定的地区，很多人工作在一个特定的行业），这种关系是不适合用在文档数据模型中的。在关系型数据库中，使用一张表中的ID来应用另外一张表的行是很常见的，因为表的联结很简单。在文档型数据库中，对于一对多的树形数据结构，联结是不需要的，因此对联结的支持通常也很弱。

如果数据库本身不支持联结，将不得不在应用程序代码中，通过多次查询数据库的方式实现联结。

而且，即使应用的最初版本适用于不需要联结的文档数据模型，随着特性的增加，数据会逐渐变得有关联性。

### 文档型数据库是否在重复历史？

尽管多对多关系和表联结在关系型数据库中日常被使用，文档型数据库依旧在争论表达这种关系的最佳方式。这种争论甚至比NoSQL本身还要古老，实际上可以追溯到数据库系统发展的初期。

在20世纪70年代，用于商业数据处理的最流行的数据库是IBM研发的**Information Management System**（IMS）。IMS在设计上使用了一种非常简单的数据模型，被称为**层次模型**，这种数据模型与JSON数据模型很相似，将数据表达为树状结构。

与文档型数据库类似，IMS很擅长处理一对多关系，但是很难处理多对多关系，并且也不支持表联结。开发者需要在冗余数据和手动维护对其他记录的引用之间作出选择。

有许多解决层次模型局限性的方式。其中最著名的两种是**关系模型**和**网状模型**。

#### 网状模型

在层次模型的树形结构中，每条记录仅有一个父节点；而在网状模型中，一条记录可以有多个父节点。因此网状模型可以用来描述多对一关系和多对多关系。

网状模型中的记录之间的连接不是外键，而是类似于编程语言中的指针（尽管是被存储在硬盘而不是内存中）。访问数据的唯一方式是，从根记录出发，沿着记录之间的连接关系组成的链条，找到需要访问的记录。这个被称为**访问路径**。

在最简单的场景中，访问路径可能是对链表的遍历，从链表的头节点开始，逐个访问链表上的节点，直到找到想要访问的节点。在多对多关系的场景下，可能会存在多条通向同一条记录的路径，开发人员需要记住这些不同的访问路径。

网状模型中的查询是通过在数据库中移动光标来实现的。如果一条记录有多个父节点，应用程序代码需要记录所有可能的关系。

尽管手动选择访问路径能够最大限度的利用当时极为有限的硬件性能，查询和更新数据库的代码会变得复杂和不灵活。在层次模型和网状模型中，必须要理解需要访问的数据的路径。访问路径是可以修改的，但是需要同步修改使用这些访问路径的代码。因此对应用的数据模型作出修改是极为困难的。

#### 关系模型

