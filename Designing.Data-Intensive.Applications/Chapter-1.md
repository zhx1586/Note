# 第一章 可靠、可扩展、可维护的应用

目前的应用大多是**数据密集型**的，而不是**计算密集型**的。CPU算力几乎不会成为这些应用的限制因素，这些应用的问题通常在于数据的数量、数据的复杂度以及数据的更新速度。

数据密集型应用通常是使用提供通用能力的标准模块搭建的。例如，大部分应用需要：

- 存储数据，以便当前应用或者其他应用能在之后查询到这些数据（数据库 databases）。

- 存储耗时操作的结果，来加速查询（缓存 caches）。

- 允许使用者通过关键词搜索数据，或者按照多种方式对数据进行过滤（搜索索引 search indexes）。

- 向其他应用发送消息，从而使任务被异步处理（流处理 stream processing）。

- 周期性地计算逐渐增加的数据的总量（批处理 batch processing）。

在需要搭建一个应用时，大多数工程师并不会选择从头开始编写一个数据存储引擎，因为数据库才是对于这个任务最合适的工具。

但是，实际情况往往也不会这么简单。目前还存着许多具有不同特性的数据系统，因为不同应用有着不同的要求。缓存和搜索索引的构建方式同样也是多种多样的。在构建一个应用时，我们仍然需要考虑，对于要处理的任务，最适合的方式是什么。并且，在单一工具无法满足应用的要求时，将多个工具组合使用也是具有挑战性的。

本书介绍了数据系统的设计准则和实例，以及如何使用这些数据系统来构建数据密集型应用。我们将会探讨不同工具之间的相同点和不同点，以及这些工具是如何实现这些特性的。

在本章中，我们将开始探讨可靠、可扩展、可维护应用的基本概念。我们将阐明这些该概念的含义，以及一些思考这些概念的方法，这将会是后续章节中所需要的。在后续章节中，我们将继续逐层介绍，构建数据密集型应用时需要考虑的设计决策。

## 对数据系统的理解

我们通常认为数据库、消息队列、缓存等是不同分类下的工具。尽管数据库和消息队列具有一些相似之处（都需要将数据存储一段时间），但是它们访问数据的方式是非常不同的，这意味着它们具有不同的特征，因此也有着不同的实现方式。

所以为什么我们将这些工具统一放在**数据系统**这个概念下呢？

近年来，出现了许多用于数据存储和数据处理的新工具。它们对多种不同的使用场景做了优化，因此不再能按照传统的方式进行分类。例如，Redis 是可以用作消息队列的数据存储系统，Kafka 是具有类似数据库的持久化能力的消息队列。分类之间的边界开始变得模糊来。

另一方面，越来越多的应用需要解决要求苛刻的或者适用性广的问题，以至于单个工具不再能满足其对数据存储和数据处理的需要。正相反，这些问题被拆分为了可以被单个工具高效处理的子任务，处理子任务的工具们组合在一起共同构成了应用代码。

例如，如果你需要一个应用管理的独立于主数据库之外的缓存层（使用 Memcached 等）或者全文搜索层（使用 Elasticsearch 等），那么通常你的应用代码应该负责保持缓存和索引与主数据库的同步性。

当你需要组合多个工具来搭建一个服务时，这个服务的接口通常会对客户端隐藏这些实现细节。此时，你有必要使用通用功能的小组件搭建一个全新的、特定功能的数据系统 。你搭建的数据系统应该提供某些方面的保证，比如：缓存在数据写入时得到了正确的校验或者更新，从而使客户端可以获得一致的结果。这就意味着你不仅是一位应用程序开发者，也是一位数据系统设计者。

如果你正在设计一个数据系统，需要考虑下面这些问题。如何保证数据是正确的和完整的，即使在系统发生故障时？如何向客户端持续提供可用的服务，即使在系统中的一部分被迫降级时？如何扩展系统来应对请求量的增长？如何设计优秀的系统对外接口？

有许多因素会影响数据系统的设计，包括设计者的技能和经验、遗留系统的依赖、交付时间的长短、对各种风险的承受能力、监管约束等。这些因素在不同场景下各不相同。

在本书中，我们重点关注对大多数软件系统都十分重要的三个因素：

- 可靠性：系统应该持续地正确工作（在预期的性能范围内提供正常的功能）即使在逆境中（硬件或者软件错误，甚至是人为因素导致的错误）。

- 可扩展性：在系统成长（数据量增加、请求量增加或者复杂度增加）过程中，应该存在合理的方式来应对这种变化。

- 可维护性：随着时间推移，会有许多不同的人参与到系统中（开发或者操作，包括维护现有功能和调整系统以适应新的用途），并且这些人可以高效地在系统之上工作。

这些名次经常被提及，但是却缺少对其含义的准确理解。出于严谨性的考虑，本章的剩余部分会探讨对可靠性、可扩展性和可维护性的理解。在后续的章节中，我们将会给出各种各样的用来实现这些特性的技术、架构和算法。

## 可靠性


